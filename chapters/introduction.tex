\section{Introduction}

As our collections of text grow larger, our need to find information in them
and infer patterns and rankings increases, too. Suffix arrays, first
described by Manber and Myers~\cite{manber1990}, allow a variety of complex 
pattern matching and pattern discovery problems to be performed in optimal time. 
There are many areas where suffix arrays are likely the most appropriate data 
structure for the task, including:

\begin{itemize}
\item
	Searching for patterns in oriental languages; as some oriental languages
    do not have spaces between certain particles, an inverted file would be
    insufficient;
\item
	Pattern discovery and visualisation using arc diagrams, as proposed by
    Wattenberg~\cite{arc:wattenberg2002};
\item
	Genome analysis~\cite{genome:abouelhoda2004, genome:flicek2009}
\end{itemize}

Due to its performance in these important applications, suffix arrays have been
the focus of intensive research over the past 20 years. On a broad
view\footnote{These will be discussed in more detail in the following 
sections.}, these improvements include several component structures such as the 
Burrows-Wheeler Transform (BWT), which enables \emph{self indexing}; we can 
discard the original text and perform fast pattern matching by using a `backward 
search'.

		\DefFig{fig:overview}{introduction/overview}{1}
			{Simplified view of the key data structures}

Backwards searching with a BWT requires a fundamental operation called a 
\emph{`rank query'}, which counts the number of symbols up to a given position in the 
string. Instead of answering a rank query by $O(N)$ comparisons over the
entire BWT, we improve rank query to $O(\log \sigma)$ where $\sigma$ 
is the alphabet size, we implement the BWT on a wavelet tree, which were 
previously binary only. 

The key motivation behind this project arises from the increasing number of
papers, such as ~\cite{yu2009}, which utilise \emph{multi-ary} Wavelet
Trees as a theoretical tool. However no known implementations of Multiary 
Wavelet Trees exist; this thesis aims to address this need, and bring theory 
closer to practice. It was expected that increasing arity will have benefits
on both the time and space performance of self-indexes which use BWT.

\subsection{Background}
In 1970 Knuth, Morris and Pratt (KMP) discovered an algorithm to match patterns 
in time proportional to the length of the string being searched~\cite{KMP77, 
McCreight76}. The
issue with the KMP algorithm is that it must search the whole string to find all
occurrences of it, thus rendering it ineffective for ranking and pattern
discovery. KMP is only useful for exact matches.

One alternative to KMP for document ranking is the use of inverted files, but
they must work with keywords and are thus inappropriate for many applications,
such as searches on certain oriental languages, and other strings that don't
have a clear definition of keywords (MIDI, for example). Suffix arrays are also 
more efficient than inverted files for searching phrases or partial 
patterns~\cite{MN10}.

This was originally
possible with a suffix tree~\cite{McCreight76}, although suffix trees require
three to five times as much space~\cite{manber1990}. A suffix array can require
around $5N$ bytes of memory~\cite{manber1990}.

There have been many additional improvements made to suffix arrays
in recent years. One such improvement is the \emph{`backward search'} 
algorithm;
since all occurrences of a pattern lie in a contiguous portion of the suffix
array, in earlier implementations we would locate the range that this pattern
lies on by successive binary searches. 

Backward search utilises the BWT in a series of rank queries, further
improving the query performance considerably ~\cite{CN08, FGM09, FMMN07, GMR06,
MN07:rankselect, MN07:selfindex, MN10, MN06}. One of the most effective data
structures for answering rank queries is the wavelet tree~\cite{CN08, FGM09,
FMMN07, GGV03, MN07:selfindex}. As proposed by Ferragina and Manzini, when a BWT 
is stored alongside a Suffix Array, it is called an 
\emph{FM-Index}\cite{fmindex:ferragina2000}.

Recently, Multiary Wavelet Trees have been used in theoretical proofs
~\cite{FMMN07, yu2009}. There are also ways of improving popcount operations and
compressing Wavelet Trees by using a structure called \emph{`RRR'}
~\cite{rrr2007}.
\\ \\
In the following sections these data structures are discussed in further detail,
including some implementation details of interest. We give a description of our
how we measured the time and space performance for each Multiary Wavelet Tree 
variation for each dataset used, and discover that although Multiary Wavelet 
Trees are faster, generalised RRR is impractical in is current form, but also 
discover that our alternative which uses binary RRR is practical.
