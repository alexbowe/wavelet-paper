\section{Preliminaries}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:mis}{preliminaries/mississippi}{0.55}
			{Array representation of	`mississippi' string}
			
Throughout this paper we represent the string we are searching as $S$, and the
pattern we are searching for as $P$. $S[i]$ represents the symbol located at
position $i$ in $S$, and $S[i..j]$ represents the substring of $S$ beginning at 
position $i$ and ending at $j$ inclusive. Strings are zero-based, so in Figure \ref{fig:mis} $S[0] = $ `m', $S[2] = $ `s', and $S[0..2] = $ `mis'.

The $log$ operation is base 2 unless otherwise stated.

\subsection{Suffix Arrays}
In its simplest form, a suffix array can be constructed for a string
$S[0..N-1]$ - where the first character of $S$ is $S[0]$, and $N$ is the
length of the string - like so:

\begin{enumerate}
	\item
		Construct an array of pointers to all suffixes ($S[0..N-1]$, 
		$S[1..N-1]$, $S[2..N-1]$, and so on...) in the string,
	\item
		Sort these pointers by the lexicographical ordering of their associated
		suffixes
\end{enumerate}

Take for example the string `mississippi' in Figure \ref{fig:mis}.
The construction of the corresponding suffix array is shown in Figure
\ref{fig:sa-make-mis}.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:sa-make-mis}{preliminaries/mississippi-sa-sort}{0.65}
			{Construction of Suffix Array for `mississippi'}



\subsection{Burrows-Wheeler Transform}
The Burrows-Wheeler Transform (BWT) is calculated by $BWT[i] = S[SA[i]-1]$, and $BWT[0] = $ `\$' (that is, it is the character previous to the suffix), as in Figure \ref{fig:sa-bwt-mis}.

When the BWT is stored in a Wavelet Tree for rank queries, this becomes what is known as a \emph{`FM-index'}, which enables backwards search.


		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:sa-bwt-mis}{preliminaries/mississippi-sa}{0.35}
			{Suffix Array and Burrows-Wheeler Transform for
			`mississippi' string}


\subsubsection{Rank Query} % TODO: REFERENCE THIS SECTION?
A Rank Query is defined as $rank(c, i) = n $, with $n$ being the number of
times symbol $c$ appears on the range $[0, i)$. For example in Figure
\ref{fig:rank-mis}, $rank(s, 9) = 3$.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:rank-mis}{preliminaries/rankquery}{0.6}
			{Rank query $rank(s, 9) = 3$ on `mississippi' Burrows-Wheeler 
			Transform}

\subsubsection{Backwards Search} % TODO: AND THIS ONE
Backwards search involves a series of paired rank queries on the BWT to locate 
the range in the Suffix Array that contains all the occurrences of the search
pattern $P$. $|P|$ pairs, of rank queries will be issued, where $|P|$ denotes the length of the pattern. The rank queries we issue are:

					$$ s' = C[P[i]] + rank(s, P[i])$$
					$$ e' = s' + (rank(e, P[i]) - rank(s, P[i]))$$

Where $s$ denotes the start of the range, initiated at $s = 0$, and $e$ is the end of the range, $e = N - 1$ for $|S| = N$. $C$ is a table of initial positions for each symbol, as in Figure \ref{fig:c-tab}\footnote{Note that we are indexing $C$ by a symbol $P[i]$, so this may be implemented with a suitable hash function.}. In the first iteration we query the final character of the pattern, so $i = |P| - 1$.  For each iteration, we decrement $i$ until zero.

An example is given in Figure \ref{fig:bws-1} through to Figure \ref{fig:bws-4},
Where the pattern \emph{`iss'} is searched for in the string `mississippi',
starting with $i = 2$, $P[2] = `s'$. The working for each rank query is shown below. We represent the current symbol as $c$ to avoid confusion between `s' and $s$ and $s'$.

The $F$ column contains the first symbol for each suffix. Note that the $F$ 
column isn't stored as we store $C$ instead.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:c-tab}{preliminaries/C-table}{0.4}
			{Table $C$ of first occurrences of each symbol}
			
		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-1}{preliminaries/bwt-1}{0.4}
			{First stage of backwards search for `iss' on `mississippi'
			 string - before any rank queries have been made.}


\begin{enumerate}
	\item
		Starting from $s = 0$ and $e = 11$ as in Figure \ref{fig:bws-1},
		and $c = P[i] = $`s' where $i = 0$, we make our first two rank queries:
			$$s' = C[c] + rank(0, c) = 8 + 0 = 8$$
			$$e' = s' + (rank(11, c) - rank(0, c)) = 8 + (3 - 0) = 11$$
	\item
		From $s = 8$ and $e = 11$ as in Figure \ref{fig:bws-2},
		and $c = P[i] = $`s' where $i = 1$, our next two rank queries are:
			$$s'' = C[c] + rank(8, c) = 8 + 0 = 8$$
			$$e'' = s'' + (rank(11, c) - rank(8, c)) = 8 + (4 - 3) = 9$$
	\item
		From $s = 8$ and $e = 11$ as in Figure \ref{fig:bws-3},
		and $c = P[i] = $`i' where $i = 0$, our final two rank queries are:
			$$s''' = C[c] + rank(8, c) = 1 + 2 = 3$$
			$$e''' = s''' + (rank(9, c) - rank(8, c)) = 3 + (2 - 2) = 4$$
\end{enumerate}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-2}{preliminaries/bwt-2}{0.4}
			{Second stage of backwards search for `iss' on `mississippi'
			string. All the occurrences of `s' lie in $SA[8..11]$.}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-3}{preliminaries/bwt-3}{0.4}
			{Third stage of backwards search for `iss' on `mississippi'
			string. All the occurrences of `ss' lie in $SA[8..9]$.}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-4}{preliminaries/bwt-4}{0.4}
			{Fourth and final stage of backwards search for `iss' on
			`mississippi' string. All the occurrences of `iss' lie in
			$SA[3..4]$.}

\clearpage
\subsection{Binary Wavelet Trees}
Binary Wavelet Trees encode the BWT as a balanced binary tree of bit vectors, to 
enable $O(\log \sigma)$ time - where $\sigma$ is the size of the alphabet - rank 
queries. The tree is defined recursively as follows:

\begin{enumerate}
    \item
		Encoding half the alphabet as 0, and half as 1, for example:
    		$$\Sigma = \{ \$, i, m, p, s \}$$
			$$enc(\Sigma) = \{ 0, 0, 0, 1, 1 \}$$
    \item
		Group each 0-encoded symbol, $\{ \$, i, m \}$, as a sub-tree
    \item
		Group each 1-encoded symbol, $\{ p, s \}$, as a sub-tree
    \item
		Reapply to each sub-tree recursively until there is only one symbol
    	left
\end{enumerate}

The encoded binary Wavelet Tree root node for the `mississippi` BWT is shown in Figure \ref{fig:wt-enc-bwt}. For a more detailed example see Figure \ref{fig:bin-wt-pp}.


		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:wt-enc-bwt}{preliminaries/encodebwt}{0.5}
			{Root node of Binary Wavelet Tree encoding for `mississippi' BWT}


After this, a rank query can be done by $\log N$ popcounts\footnote{A
$popcount(i)$ operation counts all $1$s up to a point $i$. To count $0$s, this
number is subtracted from $i$. This is equivalent to a binary rank query.} on 
the bit-vectors. For example, if we wanted to know $rank(5, e)$ in Figure 
\ref{fig:bin-wt-pp}, we use the following procedure which is illustrated in 
Figure \ref{fig:rank-bin-wt-pp}. 
We know that $enc(e) = 0$ at this level, so:

\begin{enumerate}
    \item
		Count the number of $0$s on $bitvector[0..5]$, which is $4$, this
   		gives us the index to query in our 0-child (although it is $3$, not $4$ 
		due to zero-basing);
    \item
		Calculate $popcount(3) = 2$, as $e$ is now encoded as $1$. We traverse
    	the 1-branch this time, with the next index as $1$.
    \item
		$popcount(1) = 2$, which we use as the index in the child on the
    	1-branch, with our next index as $1$.
    \item
		$popcount(1) = 0$, which we subtract from $2$, as $e$ is encoded as
    	$0$ here, and hence get $2$. Since our children at this point are leaf
    	nodes, we return $2$ as our result.
\end{enumerate}

Hence the result of $rank(5, e)$ is $2$. If we store these nodes in RRR, 
popcounts can be answered in $O(1)$ time.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bin-wt-pp}{preliminaries/binwt}{1}
			{Binary Wavelet Tree for `Peter Piper...' where spaces are displayed
			as underscores.}
			
		\DefFig{fig:multi-wt-pp}{preliminaries/fourwt}{1}
			{`Four'-ary Wavelet Tree for `Peter Piper...' where spaces are 
			displayed as underscores.}
\clearpage
		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:rank-bin-wt-pp}{preliminaries/binwt-query}{0.9}
			{Answering $rank(5, e)$ over the Binary Wavelet Tree for `Peter
			Piper...' where spaces are displayed as underscores.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{RRR}
To construct the RRR we divide the bit-vector into several so called 
\emph{superblocks}, we then divide these superblocks further, into 
\emph{blocks} of $b$ bits each, as in Figure \ref{fig:blocks}. We call the 
number of block in a superblock the \emph{superblock-factor}, $f$.

		\DefFig{fig:blocks}{preliminaries/blocks}{0.85}
			{Block division scheme for `Peter Piper...' Wavelet Tree's root
			node bit-vector}

For each of these blocks we store a class number $c$, which in the binary case 
is the number of  $1$s in the block. This is used as a lookup key in a table 
$G$, which is a table of tables, and will be explained shortly. We also store 
offset $o$, which is an index into the table at $G[c]$. See Figure 
\ref{fig:rrr-seq}.

$G$ is a table having subtables $G[c]$ for each class $c$. For every possible 
permutation of $c$ 1-bits, $G[c]$ contains an array of cumulative sums for each 
respective bit. It is important to note that the size of $o$ varies, since 
the number of possible permutations of $c$ bits, and hence entries in $G[c]$, is $b \choose c$, and can be encoded in $\log {b \choose c}$ bits. See Figure \ref{fig:bin-gtab}.

		\DefFig{fig:bin-gtab}{preliminaries/binary-g-table}{0.7}
			{Binary RRR Count Table, with example lookup for class $c = 2$
			and offset $o = 3$ in a RRR sequence}

The purpose of the superblocks is to provide partial sums at each block where $n 
\ge 0$. It also provides an initial address for the variable-length offset 
values (also using a prefix sum). After finding the first offset in a RRR
sequence, they are sampled according to their class $c$ by reading $\log {b 
\choose c}$ bits. See Figure \ref{fig:rrr-seq}.

		\DefFig{fig:rrr-seq}{preliminaries/classoffsets}{0.9}
		{RRR Sequence with three superblocks and the blocks for which they
		maintain intermediate counts}

RRR allows us to calculate popcounts on binary sequences in $O(1)$ time, and 
offers compression of our Wavelet Tree. It is possible to support multiary 
Wavelet Trees with a more extensive class allocation, which we will discuss in 
shortly.

\clearpage
\subsection{Multiary Wavelet Trees}
Multiary Wavelet Trees are analogous to their binary counterparts, although now we encode each node recursively like so:

\begin{enumerate}
    \item Encoding one $A^{th}$ of the alphabet as $0$, the next $A^{th}$ as 
		$1$, the next $N^{th}$ as $2$ and so on until $A-1$. For example, with 
		the `Peter Piper...' string:
		$$\Sigma = \{ \$, \_, P, a, c, d, e, f, i, k, l, o, p, r, s, t \}$$
	   	$$enc(\Sigma) = \{  0,  0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 \}$$
    \item Group each 0-encoded symbol as a sub-tree
    \item Group each 1-encoded symbol as a sub-tree
    \item Group each 2-encoded symbol as a sub-tree, and so on until $A-1$
    \item Reapply to each sub-tree recursively until the amount of symbols is
	less than or equal to $A - 1$.
\end{enumerate}

For an example see Figure \ref{fig:multi-wt-pp}.

It is clear that popcounts will not work
here like they do for binary, and hence the RRR requires modification too.

In order to create a shallower, multiary Wavelet Tree, we discuss three approaches.

\subsubsection{Multiary Wavelet Tree Variation 1 : Uncompressed}
It is possible to represent each encoded symbol $c$, where $c$ is an element of
${ 0, 1,..., A - 1}$ and $A$ is the arity, using $A$ bitmaps. First we construct
the bitmaps for each symbol, as in Figure... then we concatenate these bitmaps
and store them as one bitvector. A rank query then involves ranged popcount
on $N[c L, c L + i]$ at each node $N$, where $L$ is the length of the node 
string before concatenation, and $i$ is the position.

We use $A$ bits per symbol, when they could be represented in $\log A$ bits, but
this allows us to utilise binary RRR.

\subsubsection{Multiary Wavelet Tree Variation 2 : Multi-binary RRR}
\begin{itemize}
\item
  As above, bitmaps are created for each symbol
\item
  these bitmaps are stored in a binary RRR, as implemented by
  Francisco Claude.
\end{itemize}

\subsection{Generalized RRR}
\DefFig{fig:gen-gtab}{preliminaries/multi-g-table}{1}
	{`Four-ary' RRR Count Table, with example lookup for class $c = 2$, 
	which represents $(2, 2, 0, 1)$, and offset $o = 3$ in a RRR
	sequence}
	for 
	example on an alphabet $\Sigma = \{ A, B, C, D \}$ classes could be a  of counts for 
	$|\Sigma| - 1$ symbols. The G-table entries would have to hold more than one 
	cumulative sums, too. We would also need to adjust the hashing algorithm for the 
	lookup, but an upper bound is known, and hence a perfect hashing function is 
	possible.