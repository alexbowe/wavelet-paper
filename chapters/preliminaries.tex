\section{Preliminaries}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:mis}{preliminaries/mississippi}{0.55}
			{Array representation of	`mississippi' string}
			
Throughout this paper we represent the string we are searching as $S$ of length 
$|S| = N$, and the pattern we are searching for as $P$. $S[i]$ represents the 
symbol located at position $i$ in $S$, and $S[i..j]$ represents the substring of 
$S$ beginning at position $i$ and ending at $j$ inclusive. Strings are 
one-based, so in Figure \ref{fig:mis} $S[1] = $ `m', $S[3] = $ `s', and $S[1..3] 
= $ `mis'.

The $i^{th}$ \emph{suffix} is thus defined as $S[i..N]$, so the $1^{st}$ suffix 
in Figure \ref{fig:mis} is $S[1..12] = $ `mississipi\$', and the $5^{th}$ suffix 
is $S[5..12] = $ `issippi\$'. The $i^{th}$ prefix is defined as $S[1..i]$, so
the $5^{th}$ prefix in Figure \ref{fig:mis} is $S[1..5] = $ `missi'.

The $log$ operation is base 2 unless otherwise stated.

\subsection{Suffix Arrays}
In its simplest form, a suffix array can be constructed for a string
$S[1..N]$ like so:

\begin{enumerate}
	\item
		Construct an array of pointers to all suffixes $S[1..N]$, 
		$S[2..N]$, $S[3..N]$, ..., $S[N..N]$.
	\item
		Sort these pointers by the lexicographical ordering of their associated
		suffixes.
\end{enumerate}

Take for example the string `mississippi' in Figure \ref{fig:mis}.
The construction of the corresponding suffix array is shown in Figure
\ref{fig:sa-make-mis}.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:sa-make-mis}{preliminaries/mississippi-sa-sort}{0.65}
			{Construction of Suffix Array for `mississippi'.}



\subsection{Burrows-Wheeler Transform}
The Burrows-Wheeler Transform (BWT) is calculated by $BWT[i] = S[SA[i]-1]$, and $BWT[1] = $ `\$' (that is, it is the character previous to the suffix), as in Figure \ref{fig:sa-bwt-mis}.

When the BWT is stored in a Wavelet Tree for rank queries, this becomes what is known as a \emph{`FM-index'}, which enables backwards search.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:sa-bwt-mis}{preliminaries/mississippi-sa}{0.35}
			{Suffix Array and Burrows-Wheeler Transform for
			`mississippi' string}

\subsubsection{Rank Query}
A Rank Query is defined as $rank(i, c) = n $, with $n$ being the number of
times symbol $c$ appears on the range $[1, i]$. For example in Figure
\ref{fig:rank-mis}, $rank(9, s) = 3$. If $i \le 0$ then $rank(i, c) = 0$.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:rank-mis}{preliminaries/rankquery}{0.6}
			{Rank query $rank(9, s) = 3$ on `mississippi' Burrows-Wheeler 
			Transform}

\subsubsection{Backward Search}
Backwards search involves a series of paired rank queries on the BWT to locate 
the range in the Suffix Array that contains all the occurrences of the search
pattern $P$. $|P|$ pairs, of rank queries will be issued, where $|P|$ denotes the length of the pattern. The rank queries we issue are:

					$$ s' = C[P[i]] + rank(s - 1, P[i]) + 1$$
					$$ e' = C[P[i]] + rank(e, P[i])$$

Where $s$ denotes the start of the range, initiated at $s = 1$, and $e$ is the 
end of the range, $e = N$. $C$ is an array containing the count of all symbols 
in $\Sigma$ which sort lexicographically before $P[i]$, where $\Sigma$ is the 
alphabet from our original string $S$, as in Figure 
\ref{fig:c-tab}\footnote{Note that we are indexing $C$ by a symbol $P[i]$, so 
this may be implemented with a suitable hash function.}. In the first iteration 
we query the final character of the pattern, so $i = |P| - 1$.  For each 
iteration, we decrement $i$ until zero, or $e < s$, which indiciates that
the pattern doesn't exist in our original string.

An example is given in Figure \ref{fig:bws-1} through to Figure \ref{fig:bws-4},
Where the pattern \emph{`iss'} is searched for in the string `mississippi',
starting with $i = 3$, $P[3] = `s'$. The working for each rank query is shown below. We represent the current symbol as $c$ to avoid confusion between `s' and $s$ and $s'$.

The $F$ column contains the first symbol for each suffix. Note that the $F$ 
column isn't stored as we store $C$ instead.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:c-tab}{preliminaries/C-table}{0.3}
			{Table $C$ of first occurrences of each symbol}
			
		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-1}{preliminaries/bwt-1}{0.5}
			{First stage of backwards search for `iss' on `mississippi'
			 string - before any rank queries have been made.}


\begin{enumerate}
	\item
		Starting from $s = 1$ and $e = 12$ as in Figure \ref{fig:bws-1},
		and $c = P[i] = $`s' where $i = 3$, we make our first two rank queries:
			$$s' = C[c] + rank(0, c) + 1 = 8 + 0 + 1 = 9$$
			$$e' = C[c] + rank(12, c) = 8 + 4 = 12$$
	\item
		From $s = 9$ and $e = 11$ as in Figure \ref{fig:bws-2},
		and $c = P[i] = $`s' where $i = 2$, our next two rank queries are:
			$$s'' = C[c] + rank(8, c) + 1 = 8 + 2 + 1 = 11$$
			$$e' = C[c] + rank(12, c) = 8 + 4 = 12$$
	\item
		From $s = 11$ and $e = 12$ as in Figure \ref{fig:bws-3},
		and $c = P[i] = $`i' where $i = 1$, our final two rank queries are:
			$$s''' = C[c] + rank(10, c) + 1 = 1 + 2 + 1 = 4$$
			$$e''' = C[c] + rank(12, c) = 1 + 4 = 5$$
\end{enumerate}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-2}{preliminaries/bwt-2}{0.5}
			{Second stage of backwards search for `iss' on `mississippi'
			string. All the occurrences of `s' lie in $SA[9..12]$.}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-3}{preliminaries/bwt-3}{0.5}
			{Third stage of backwards search for `iss' on `mississippi'
			string. All the occurrences of `ss' lie in $SA[11..12]$.}

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bws-4}{preliminaries/bwt-4}{0.5}
			{Fourth and final stage of backwards search for `iss' on
			`mississippi' string. All the occurrences of `iss' lie in
			$SA[4..5]$.}

\clearpage
\subsection{Binary Wavelet Trees}
Binary Wavelet Trees encode the BWT as a balanced binary tree of bit vectors, to 
enable $O(\log \sigma)$ time - where $\sigma$ is the size of the alphabet - rank 
queries. The tree is defined recursively as follows:

\begin{enumerate}
    \item
		Encoding half the alphabet as 0, and half as 1, for example:
    		$$\Sigma = \{ \$, i, m, p, s \}$$
			$$enc(\Sigma) = \{ 0, 0, 0, 1, 1 \}$$
    \item
		Group each 0-encoded symbol, $\{ \$, i, m \}$, as a sub-tree
    \item
		Group each 1-encoded symbol, $\{ p, s \}$, as a sub-tree
    \item
		Reapply to each sub-tree recursively until there is only one symbol
    	left
\end{enumerate}

The encoded binary Wavelet Tree root node for the `mississippi` BWT is shown in Figure \ref{fig:wt-enc-bwt}. For a more detailed example see Figure \ref{fig:bin-wt-pp}.


		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:wt-enc-bwt}{preliminaries/encodebwt}{0.5}
			{Root node of Binary Wavelet Tree encoding for `mississippi' BWT}


After this, a rank query can be done by $\log N$ popcounts\footnote{A
$popcount(i)$ operation counts all $1$s up to a point $i$. To count $0$s, this
number is subtracted from $i$. This is equivalent to a binary rank query.} on 
the bit-vectors. For example, if we wanted to know $rank(6, e)$ in Figure 
\ref{fig:bin-wt-pp}, we use the following procedure which is illustrated in 
Figure \ref{fig:rank-bin-wt-pp}. 
We know that $enc(e) = 0$ at this level, so:

\begin{enumerate}
    \item
		Count the number of $0$s on $bitvector[1..6]$, which is $4$, this
   		gives us the index to query in our 0-child.
    \item
		Calculate $popcount(4) = 2$, as $e$ is now encoded as $1$. We traverse
    	the 1-branch this time, with the next index as $1$.
    \item
		$popcount(2) = 2$, which we use as the index in the child on the
    	1-branch, with our next index as $1$.
    \item
		$popcount(2) = 0$, which we subtract from $2$, as $e$ is encoded as
    	$0$ here, and hence get $2$. Since our children at this point are leaf
    	nodes, we return $2$ as our result.
\end{enumerate}

Hence the result of $rank(6, e)$ is $2$. If we store these nodes in RRR, 
popcounts can be answered in $O(1)$ time.

		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:bin-wt-pp}{preliminaries/binwt}{1}
			{Binary Wavelet Tree for `Peter Piper...' where spaces are displayed
			as underscores.}
			
		\DefFig{fig:multi-wt-pp}{preliminaries/fourwt}{1}
			{`Four'-ary Wavelet Tree for `Peter Piper...' where spaces are 
			displayed as underscores.}
\clearpage
		%%%%%%%%%%%%%%%%%%%% IMAGE %%%%%%%%%%%%%%%%%%%%
		\DefFig{fig:rank-bin-wt-pp}{preliminaries/binwt-query}{0.9}
			{Answering $rank(6, e)$ over the Binary Wavelet Tree for `Peter
			Piper...' where spaces are displayed as underscores.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{RRR}
To construct the RRR we divide the bit-vector into several so called 
\emph{superblocks}, we then divide these superblocks further, into 
\emph{blocks} of $b$ bits each, as in Figure \ref{fig:blocks}. We call the 
number of block in a superblock the \emph{superblock-factor}, $f$.

		\DefFig{fig:blocks}{preliminaries/blocks}{0.85}
			{Block division scheme for `Peter Piper...' Wavelet Tree's root
			node bit-vector}

For each of these blocks we store a class number $c$, which in the binary case 
is the number of  $1$s in the block. This is used as a lookup key in a table 
$G$, which is a table of tables, and will be explained shortly. We also store 
offset $o$, which is an index into the table at $G[c]$. See Figure 
\ref{fig:rrr-seq}.

$G$ is a table having subtables $G[c]$ for each class $c$. For every possible 
permutation of $c$ 1-bits, $G[c]$ contains an array of cumulative sums for each 
respective bit. It is important to note that the size of $o$ varies, since 
the number of possible permutations of $c$ bits, and hence entries in $G[c]$, is $b \choose c$, and can be encoded in $\log {b \choose c}$ bits. See Figure \ref{fig:bin-gtab}.

The purpose of the superblocks is to provide partial sums at each block where $n 
\ge 0$. It also provides an initial address for the variable-length offset 
values (also using a prefix sum). After finding the first offset in a RRR
sequence, they are sampled according to their class $c$ by reading $\lceil\log 
{b \choose c}\rceil$ bits. See Figure \ref{fig:rrr-seq}.

		\DefFig{fig:bin-gtab}{preliminaries/binary-g-table}{0.7}
		{Binary RRR Count Table, with example lookup for class $c = 2$
		and offset $o = 3$ in a RRR sequence}

		\DefFig{fig:rrr-seq}{preliminaries/superblocks}{0.9}
		{RRR Sequence with three superblocks and the blocks for which they
		maintain intermediate counts. The dashed lines indicate what
		the superblocks are used for, and what they are composed of.}

RRR allows us to calculate popcounts on binary sequences in $O(1)$ time, and 
offers compression of our Wavelet Tree. It is possible to support multiary 
Wavelet Trees using RRR with a more extensive class allocation, which we will 
discuss shortly.

\clearpage
\subsection{Multiary Wavelet Trees}
Multiary Wavelet Trees are analogous to their binary counterparts, although now we encode each node recursively like so:

\begin{enumerate}
    \item Encoding one $A^{th}$ of the alphabet as $0$, the next $A^{th}$ as 
		$1$, the next $N^{th}$ as $2$ and so on until $A-1$. For example, with 
		the `Peter Piper...' string:
		$$\Sigma = \{ \$, \_, P, a, c, d, e, f, i, k, l, o, p, r, s, t \}$$
	   	$$enc(\Sigma) = \{  0,  0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 \}$$
    \item Group each 0-encoded symbol as a sub-tree
    \item Group each 1-encoded symbol as a sub-tree
    \item Group each 2-encoded symbol as a sub-tree, and so on until $A-1$
    \item Reapply to each sub-tree recursively until the amount of symbols is
	less than or equal to $A - 1$.
\end{enumerate}

See Figure \ref{fig:multi-wt-pp} for a multiary Wavelet Tree constructed over
the `Peter Piper...' string.\\

Popcounts will not work here like they do for binary. We discuss three 
alternative approaches in the following sections.

\subsubsection{Multiary Wavelet Tree Variation 1 : Uncompressed}
		\DefFig{fig:bitmaps}{preliminaries/bitmaps}{0.4}
		{Concatenated bitmap binary encoding of multiary Wavelet Tree Node
		representing `eeecedecfcedee' from the `Peter Piper...' string.}
		
It is possible to represent each encoded symbol $c$, where $c$ is an element of
${ 0, 1,..., A - 1}$ and $A$ is the arity, using $A$ bitmaps. First we construct
the bitmaps for each symbol, as in Figure \ref{fig:bitmaps}, then we concatenate these bitmaps and store them as one 
bit-vector. A rank query then involves ranged popcount on $N[c L, c L + i]$ at 
each node $N$, where $L$ is the length of the node string before concatenation, 
and $i$ is the position.

We use $A$ bits per symbol, when they could be represented in $\log A$ bits, but
this allows us to utilise binary RRR.

\subsubsection{Multiary Wavelet Tree Variation 2 : Multi-Binary RRR}
Like the uncompressed version, bitmaps are created for each symbol and 
concatenated, but the bit-vector is stored in a binary RRR sequence. A query 
then becomes two popcounts\footnote{In our implementation we pre-calculate the 
first popcount for each symbol and store it with the node.};
	\begin{align}
	popcount(c * L - 1) \\
	popcount(c * L + i)
	\end{align}

Where $c$ is the symbol we are querying at position $i$,
$c > 0$, and $L$ is 
the original length before concatenation. If $c = 0$ then we say the result of 
the first popcount is $0$. The final result of $rank(i, c)$ is calculated as 
the second popcount minus the first.

This variation means that we won't need to store a bigger $G$ table to 
accommodate the additional classes when increasing the arity, when compared with
a generalised RRR structure, but does not offer the same sequence compression as
the concatenated bitmaps take more bits than required.\\

Our third variation stores the symbols (without binary encoding) in a 
generalised RRR structure.

\subsection{Generalised RRR}

\DefFig{fig:gen-gtab}{preliminaries/multi-g-table}{1}
	{`Four-ary' RRR Count Table, with example lookup for class $c = 2$, 
	which represents $(2, 2, 0, 1)$, and offset $o = 3$ in a RRR
	sequence}
	
The generalised RRR structure differs from binary RRR in that it accepts
sequences of symbols on the range $[0..A-1]$ for arity $A$, which requires these
differences:

\begin{itemize}
	\item
		Rather than simply being the number of 1-bits, classes are now 
		considered to be a tuple of $(N^0, N^1, ..., N^{A-1})$ for a given 
		block, where $N^0$ is the number of $0$s, $N^1$ is the number of $1$s, 
		and so on. The RRR sequence still stores classes as a unique integer, 
		though.

	\item
		Rather than having $b \choose N^1$ permutations per class for blocksize 
		$b$, there are now ${b \choose N^0, N^1,...,N^{A-1}} = 
		\prod_{i = 1}^{A} {{b - \sum_{j = 1}^{i - 1} N^j} \choose N^i}
		$ different permutations\footnote{This grows rapidly as arity increases, 
		so our implementation only stored the classes and offsets that we 
		encountered in an attempt to make use of sparsity.}.
		Each offset value $o$ therefore requires $\lceil\log {b \choose N^0, 
		N^1,...,N^{A-1}}\rceil$ bits.

	\item
		The $G$ table must also store cumulative ranks for each symbol, per 
		permutation. See Figure \ref{fig:gen-gtab}.

	\item
		Each superblock now has $A$ partial sums of the ranks for $f$ blocks, 
		where $f$ is the super-block factor; a partial rank for each symbol.
\end{itemize}
